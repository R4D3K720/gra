<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0d12" />
  <title>Tap Runner ‚Äì Mobile</title>
  <style>
    /* Podstawy: nic globalnie nie blokujemy */
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0d12;
      color: #fff;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, sans-serif;
      -webkit-user-select: none;
      user-select: none;
      overscroll-behavior: none;
    }
    /* P≈Ç√≥tno gry ‚Äì tylko tu wy≈ÇƒÖczamy gesty (≈ºeby nie przewija≈Ço ekranu) */
    #game {
      width: 100vw;
      height: 100vh;
      display: block;
      background: radial-gradient(1200px 800px at 50% 10%, #161a28 0%, #0b0d12 60%);
      touch-action: none;             /* wa≈ºne dla iOS/Android */
      -webkit-touch-callout: none;
    }
    /* Szklane ‚Äûpigu≈Çki‚Äù UI ‚Äì w pe≈Çni klikalne */
    .ui {
      position: fixed;
      top: calc(env(safe-area-inset-top) + 10px);
      left: calc(env(safe-area-inset-left) + 10px);
      right: calc(env(safe-area-inset-right) + 10px);
      display: flex;
      justify-content: space-between;
      gap: 10px;
      z-index: 5;
      pointer-events: none; /* ca≈Ço≈õƒá nie ≈Çapie, ale same pigu≈Çki tak */
    }
    .pill {
      pointer-events: auto; /* przyciski dzia≈ÇajƒÖ na telefonie */
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      font-weight: 700;
      text-shadow: 0 2px 8px rgba(0,0,0,.45);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .btn { cursor: pointer; transition: transform .08s ease; }
    .btn:active { transform: scale(.96); }

    /* Overlays (start/koniec/pauza) ‚Äì klikalne */
    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 24px;
      background: radial-gradient(1200px 800px at 50% 10%, rgba(255,255,255,.07), transparent 60%);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      z-index: 10;
    }
    .hidden { display: none; }
    .card {
      width: min(92vw, 520px);
      background: rgba(23,26,38,.9);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 24px 64px rgba(0,0,0,.5);
    }
    h1 { margin: 6px 0 2px; font-size: clamp(24px, 5vw, 36px); }
    p { margin: 8px 0 0; opacity: .9; }
    .big {
      margin-top: 14px;
      width: 100%;
      padding: 16px 20px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      font-weight: 800;
      letter-spacing: .6px;
      text-transform: uppercase;
      background: linear-gradient(90deg, #67e8f9, #a78bfa, #f472b6);
      color: #0f1116;
      box-shadow: 0 10px 30px rgba(164,120,250,.25);
    }
    .ghost {
      margin-top: 10px;
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255,255,255,.25);
      box-shadow: none;
    }
  </style>
</head>
<body>
  <canvas id="game" aria-label="Tap Runner ‚Äì Mobile"></canvas>

  <div class="ui">
    <div class="pill" id="score">Punkty: 0</div>
    <div class="pill">Rekord: <span id="best">0</span></div>
    <div class="pill btn" id="pauseBtn" role="button" aria-label="Pauza">‚è∏Ô∏è Pauza</div>
  </div>

  <!-- START / CONTINUE -->
  <div class="overlay" id="startOverlay">
    <div class="card">
      <h1>üèÉ‚Äç‚ôÇÔ∏è Tap Runner</h1>
      <p>Dotknij ekranu, by skakaƒá. Zbieraj üíé, unikaj przeszk√≥d. Dzia≈Ça ‚Äûtapnij, by kontynuowaƒá‚Äù.</p>
      <button class="big" id="playBtn">‚ñ∂Ô∏è Start</button>
      <button class="big ghost" id="addBtn">‚ûï Dodaj do ekranu poczƒÖtkowego</button>
    </div>
  </div>

  <!-- GAME OVER -->
  <div class="overlay hidden" id="overOverlay">
    <div class="card">
      <h1>üí• Koniec gry!</h1>
      <p>Wynik: <b id="finalScore">0</b> ‚Ä¢ Rekord: <b id="finalBest">0</b></p>
      <button class="big" id="againBtn">üîÅ Zagraj ponownie</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

  // UI
  const startOv = document.getElementById('startOverlay');
  const overOv  = document.getElementById('overOverlay');
  const playBtn = document.getElementById('playBtn');
  const againBtn= document.getElementById('againBtn');
  const pauseBtn= document.getElementById('pauseBtn');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const addBtn  = document.getElementById('addBtn');

  // Rozdzielczo≈õƒá i dopasowanie pod ekran + notcha
  let DPR = Math.min(2, window.devicePixelRatio || 1);
  let W=0, H=0, lastTs=0;

  function resize() {
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // Stan gry
  const S = {
    running:false, paused:false, t:0, score:0, best:Number(localStorage.getItem('tr_best')||0),
    speed:380, gravity:1650, jump:560, holdMs:160
  };
  bestEl.textContent = S.best;

  // Obiekty
  const player = { x:0, y:0, w:44, h:44, vy:0, grounded:true, spin:0 };
  const floor  = { y:0, h:18 };
  const obs = [], gems = [];

  // Wej≈õcie ‚Äì tylko na canvasie blokujemy gesty (≈ºeby nie przewijaƒá)
  let pressing=false, pressStart=0;

  function attachCanvasControls() {
    // pointer events dzia≈ÇajƒÖ i na dotyk, i na mysz
    const onDown = (e) => {
      e.preventDefault(); // tylko na canvasie
      if (!S.running) return;
      pressing = true; pressStart = performance.now();
      if (player.grounded) { player.vy = -S.jump; player.grounded = false; }
    };
    const onUp = (e) => { pressing = false; };

    canvas.addEventListener('pointerdown', onDown, { passive:false });
    canvas.addEventListener('pointerup', onUp, { passive:true });
    canvas.addEventListener('pointercancel', onUp, { passive:true });

    // Start/continue tap na canvasie te≈º dzia≈Ça:
    canvas.addEventListener('click', () => {
      if (!S.running) startGame(); // ‚Äûtapnij, by kontynuowaƒá‚Äù
    }, { passive:true });

    // Klawiatura (na PC)
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') onDown(e);
      else if (e.code === 'KeyP') togglePause();
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') onUp(e);
    });
  }
  attachCanvasControls();

  // PWA ‚ÄûAdd to Home Screen‚Äù (iOS: przez Safari ‚Äì Udostƒôpnij ‚Üí Dodaj)
  let deferredPrompt = null;
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
  });
  addBtn.addEventListener('click', async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
    } else {
      alert('Na iPhonie: Udostƒôpnij ‚Üí Dodaj do ekranu poczƒÖtkowego');
    }
  });

  // Start / restart / pauza
  playBtn.addEventListener('click', startGame, { passive:true });
  againBtn.addEventListener('click', startGame, { passive:true });
  pauseBtn.addEventListener('click', () => {
    if (!S.running) return;
    S.paused = !S.paused;
    pauseBtn.textContent = S.paused ? '‚ñ∂Ô∏è Wzn√≥w' : '‚è∏Ô∏è Pauza';
    if (!S.paused) { lastTs = performance.now(); loop(0); }
  }, { passive:true });

  function startGame() {
    S.running = true; S.paused = false; S.t=0; S.score=0; S.speed=380;
    player.w = player.h = Math.max(30, Math.min(W,H)*0.045);
    player.x = W*0.22; floor.h = Math.max(12*DPR, Math.min(W,H)*0.015);
    floor.y = H - floor.h; player.y = floor.y - player.h;
    player.vy = 0; player.grounded = true; player.spin = 0;
    obs.length=0; gems.length=0; lastTs=0;
    startOv.classList.add('hidden'); overOv.classList.add('hidden');
    loop(0);
  }

  function gameOver() {
    S.running = false;
    document.getElementById('finalScore').textContent = Math.floor(S.score);
    if (S.score > S.best) {
      S.best = Math.floor(S.score);
      localStorage.setItem('tr_best', S.best);
    }
    document.getElementById('finalBest').textContent = S.best;
    overOv.classList.remove('hidden');
  }

  // Losowo≈õci i timery
  let spawnMs=0, gemMs=800;
  const R = (a,b)=>Math.random()*(b-a)+a;

  // Pƒôtla gry
  function loop(ts) {
    if (!S.running || S.paused) return;
    if (!lastTs) lastTs = ts;
    const dt = Math.min(0.032, (ts - lastTs)/1000); // clamp 32ms
    lastTs = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    S.t += dt;
    S.speed += dt*12;
    S.score += dt*(S.speed/9.5);
    scoreEl.textContent = 'Punkty: ' + Math.floor(S.score);

    // skok trzymany
    if (!player.grounded && pressing) {
      const held = Math.min(S.holdMs, performance.now()-pressStart);
      if (held < S.holdMs) player.vy -= 920 * dt;
    }

    // grawitacja/ruch
    player.vy += S.gravity * dt;
    player.y  += player.vy * dt;
    if (player.y + player.h >= floor.y) {
      player.y = floor.y - player.h;
      player.vy = 0;
      player.grounded = true;
    } else {
      player.grounded = false;
    }

    // przeszkody
    spawnMs -= dt*1000;
    if (spawnMs <= 0) {
      const gapMin = 700 - Math.min(420, S.t*22);
      const gapMax = 1100 - Math.min(560, S.t*34);
      spawnMs = R(gapMin, gapMax);
      const w = R(player.w*.9, player.w*1.6);
      const h = R(player.h*.9, player.h*1.6);
      obs.push({ x: W+w, y: floor.y-h, w, h, vx: -S.speed, c:'#f472b6' });
      if (Math.random() < Math.min(0.28, S.t/40)) {
        const w2=R(player.w*.8, player.w*1.3), h2=R(player.h*.8, player.h*1.4);
        obs.push({ x: W+w+R(90,150), y: floor.y-h2, w:w2, h:h2, vx:-S.speed, c:'#a78bfa' });
      }
    }
    // diamenciki
    gemMs -= dt*1000;
    if (gemMs <= 0) {
      gemMs = R(1500, 2600);
      const s = player.w*.62;
      gems.push({ x: W+s, y: floor.y - player.h - R(60,150)*DPR, w:s, h:s, vx:-S.speed*1.02, t:0 });
    }

    // ruch / usuwanie
    for (let i=obs.length-1;i>=0;i--) {
      const o = obs[i]; o.x += o.vx*dt; if (o.x + o.w < -32) obs.splice(i,1);
    }
    for (let i=gems.length-1;i>=0;i--) {
      const g = gems[i]; g.x += g.vx*dt; g.t += dt; if (g.x + g.w < -32) gems.splice(i,1);
    }

    // kolizje
    for (const o of obs) if (hit(player,o)) { gameOver(); return; }
    for (let i=gems.length-1;i>=0;i--) {
      const g=gems[i];
      if (hit(player,g)) { S.score += 28; gems.splice(i,1); player.spin = Math.PI*2; }
    }
    if (player.spin > 0) player.spin = Math.max(0, player.spin - dt*8);
  }

  // rysowanie
  function draw() {
    ctx.clearRect(0,0,W,H);
    // t≈Ço
    const t = S.t;
    for (let r=1;r<=3;r++){
      const sp=S.speed*(0.08*r), y=H*(0.18*r), n=12*r;
      for (let i=0;i<n;i++){
        const x=((i*260+(t*-sp)*0.5)%(W+260))-130;
        const s=2*DPR*r*.6;
        ctx.globalAlpha=0.22+0.1*r;
        ctx.fillStyle='#cbd5e1';
        ctx.fillRect(x, y+Math.sin((i+t)*0.8)*4*r, s, s);
        ctx.globalAlpha=1;
      }
    }
    // pod≈Çoga
    ctx.fillStyle='#121420';
    ctx.fillRect(0, floor.y, W, floor.h);

    // przeszkody
    for (const o of obs) {
      roundRect(ctx, o.x, o.y, o.w, o.h, 8*DPR);
      ctx.fillStyle=o.c; ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.lineWidth=2*DPR; ctx.stroke();
    }
    // diamenciki
    for (const g of gems) {
      const pul=1+Math.sin(g.t*6)*.12;
      ctx.save(); ctx.translate(g.x+g.w/2, g.y+g.h/2); ctx.scale(pul,pul);
      ctx.strokeStyle='#67e8f9'; ctx.lineWidth=3*DPR;
      diamond(ctx, -g.w/2, -g.h/2, g.w, g.h); ctx.stroke();
      ctx.restore();
    }
    // gracz
    drawPlayer();
  }

  function roundRect(c,x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    c.beginPath();
    c.moveTo(x+rr,y);
    c.arcTo(x+w,y,x+w,y+h,rr);
    c.arcTo(x+w,y+h,x,y+h,rr);
    c.arcTo(x,y+h,x,y,rr);
    c.arcTo(x,y,x+w,y,rr);
    c.closePath();
  }
  function diamond(c,x,y,w,h){
    c.beginPath();
    c.moveTo(x+w/2,y);
    c.lineTo(x+w,y+h/2);
    c.lineTo(x+w/2,y+h);
    c.lineTo(x,y+h/2);
    c.closePath();
  }
  function drawPlayer(){
    const {x,y,w,h}=player;
    ctx.save(); ctx.translate(x+w/2, y+h/2); if(player.spin) ctx.rotate(player.spin*.5);
    const grad=ctx.createLinearGradient(-w/2,-h/2,w/2,h/2);
    grad.addColorStop(0,'#67e8f9'); grad.addColorStop(1,'#a78bfa');
    ctx.fillStyle=grad; roundRect(ctx,-w/2,-h/2,w,h,12*DPR); ctx.fill();
    ctx.fillStyle='#0f1116';
    const eye=Math.max(2*DPR, w*.08);
    ctx.beginPath(); ctx.arc(-w*.18, -h*.06, eye, 0, Math.PI*2);
    ctx.arc( w*.18, -h*.06, eye, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    // cie≈Ñ
    const sw=w*.9, sx=x+w/2-sw/2, sy=floor.y+4*DPR, sh=6*DPR;
    ctx.globalAlpha=.25; ctx.fillStyle='#000'; roundRect(ctx,sx,sy,sw,sh,sh/2); ctx.fill(); ctx.globalAlpha=1;
  }
  function hit(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // Ustaw startowy ekran
  function showStart(){ startOv.classList.remove('hidden'); }
  showStart();

  // Umo≈ºliwiamy kontynuacjƒô jednym tapniƒôciem: klik w overlay lub canvas
  startOv.addEventListener('click', () => { if (!S.running) startGame(); }, { passive:true });
  overOv.addEventListener('click',  (e) => {
    // klik w t≈Ço (nie w przycisk) te≈º wznawia
    if (e.target === overOv && !S.running) startGame();
  }, { passive:true });

})();
</script>
</body>
</html>