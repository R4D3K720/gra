<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
<meta name="theme-color" content="#0b0d12">
<title>Crystal Farm 3D</title>
<style>
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:#0b0d12;color:#fff;font-family:-apple-system,system-ui,Segoe UI,Roboto,Ubuntu,sans-serif;overscroll-behavior:none}
  #app{position:fixed;inset:0}
  canvas{display:block;width:100vw;height:100vh}
  /* HUD */
  .hud{position:fixed;top:calc(env(safe-area-inset-top) + 10px);left:calc(env(safe-area-inset-left)+10px);right:calc(env(safe-area-inset-right)+10px);display:flex;gap:8px;align-items:center;justify-content:space-between;z-index:5;pointer-events:none}
  .pill{pointer-events:auto;display:inline-flex;gap:8px;align-items:center;padding:10px 14px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);font-weight:700;letter-spacing:.3px;text-shadow:0 2px 8px rgba(0,0,0,.45)}
  .stats{display:flex;gap:8px}
  .hearts{display:flex;gap:6px}
  .heart{width:18px;height:18px;border-radius:50%;background:radial-gradient(circle at 30% 30%,#ff7aa2,#e11d48)}
  /* On-screen controls */
  .controls{position:fixed;inset:0;pointer-events:none;z-index:6}
  .stickArea{position:absolute;bottom:calc(env(safe-area-inset-bottom)+18px);left:calc(env(safe-area-inset-left)+18px);width:160px;height:160px;border-radius:20px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);pointer-events:auto;touch-action:none}
  .stick{position:absolute;left:50%;top:50%;width:72px;height:72px;transform:translate(-50%,-50%);border-radius:999px;background:rgba(255,255,255,.2);border:1px solid rgba(255,255,255,.35)}
  .btnDash{position:absolute;right:calc(env(safe-area-inset-right)+18px);bottom:calc(env(safe-area-inset-bottom)+18px);width:120px;height:120px;border-radius:24px;background:linear-gradient(90deg,#67e8f9,#a78bfa,#f472b6);border:none;box-shadow:0 12px 36px rgba(164,120,250,.35);pointer-events:auto;touch-action:manipulation;font-weight:900;color:#0b0d12;letter-spacing:.5px}
  .btnDash:active{transform:scale(.98)}
  /* overlays */
  .overlay{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 10%,rgba(255,255,255,.07),transparent 60%);backdrop-filter:blur(2px);-webkit-backdrop-filter:blur(2px);z-index:10}
  .card{width:min(92vw,560px);background:rgba(23,26,38,.9);border:1px solid rgba(255,255,255,.15);border-radius:16px;padding:20px;text-align:center;box-shadow:0 24px 64px rgba(0,0,0,.5)}
  .big{margin-top:12px;width:100%;padding:14px 16px;border-radius:12px;border:none;font-weight:800;letter-spacing:.6px;text-transform:uppercase;background:linear-gradient(90deg,#67e8f9,#a78bfa,#f472b6);color:#0b0d12;box-shadow:0 10px 30px rgba(164,120,250,.25)}
  .ghost{margin-top:10px;background:transparent;color:#fff;border:1px solid rgba(255,255,255,.25);box-shadow:none}
  .hidden{display:none}
  /* tips */
  .tip{position:fixed;left:50%;bottom:calc(env(safe-area-inset-bottom)+10px);transform:translateX(-50%);padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);z-index:7;opacity:0;transition:opacity .25s, transform .25s}
  .tip.show{opacity:1;transform:translate(-50%,-4px)}
</style>
</head>
<body>
<div id="app"></div>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="pill">üíé Monety: <span id="coins">0</span></div>
  <div class="stats">
    <div class="pill">üå± Zasiej (50)</div>
    <div class="pill">‚è±Ô∏è Wzrost: 12s</div>
    <div class="pill">‚ö° Dasz</div>
  </div>
  <div class="pill hearts" id="hearts"></div>
</div>

<!-- Controls -->
<div class="controls">
  <div class="stickArea" id="stickArea"><div class="stick" id="stick"></div></div>
  <button class="btnDash" id="btnDash" aria-label="Dash/Atak">DASH</button>
</div>

<!-- Overlays -->
<div class="overlay" id="startOv">
  <div class="card">
    <h1>üåå Crystal Farm 3D</h1>
    <p>Uprawiaj kryszta≈Çy na wyspie, zbieraj monety i odpieraj ataki slim√≥w.<br>Lewy kciuk ‚Äì joystick, prawy ‚Äì DASH (atak).</p>
    <button class="big" id="playBtn">‚ñ∂Ô∏è Zaczynamy</button>
    <button class="big ghost" id="addBtn">‚ûï Dodaj do ekranu poczƒÖtkowego</button>
  </div>
</div>

<div class="overlay hidden" id="gameOver">
  <div class="card">
    <h1>üí• Koniec gry</h1>
    <p>Wynik (monety): <b id="finalScore">0</b></p>
    <button class="big" id="againBtn">üîÅ Jeszcze raz</button>
  </div>
</div>

<div class="tip" id="tip">Dotknij p≈Çytki, aby zasadziƒá / zebraƒá</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

<script>
(() => {
  // ====== Basics ======
  const app = document.getElementById('app');
  const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  app.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0d12);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
  camera.position.set(0, 8, 12);

  const hemi = new THREE.HemisphereLight(0xa3baff, 0x1b1f2a, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.2);
  dir.position.set(6, 10, 4);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  dir.shadow.camera.near = 1; dir.shadow.camera.far = 40;
  scene.add(dir);

  // Subtle fog for depth
  scene.fog = new THREE.FogExp2(0x0b0d12, 0.035);

  // ====== Island ======
  const island = new THREE.Group();
  scene.add(island);

  const islandTopGeo = new THREE.CircleGeometry(8, 64);
  const islandTopMat = new THREE.MeshStandardMaterial({ color:0x18212f, roughness:0.85, metalness:0.05 });
  const islandTop = new THREE.Mesh(islandTopGeo, islandTopMat);
  islandTop.rotation.x = -Math.PI/2;
  islandTop.receiveShadow = true;
  island.add(islandTop);

  // Rim (sides)
  const rimGeo = new THREE.CylinderGeometry(8, 7.5, 2, 64, 1, true);
  const rimMat = new THREE.MeshStandardMaterial({ color:0x0e1522, roughness:0.9, metalness:0.05, side:THREE.DoubleSide });
  const rim = new THREE.Mesh(rimGeo, rimMat);
  rim.position.y = -1;
  rim.receiveShadow = true; rim.castShadow = true;
  island.add(rim);

  // Subtle stars plane below
  const starGeo = new THREE.PlaneGeometry(80,80);
  const starMat = new THREE.MeshBasicMaterial({ color:0x0a0c12 });
  const star = new THREE.Mesh(starGeo, starMat);
  star.rotation.x = -Math.PI/2; star.position.y = -2.1;
  scene.add(star);

  // ====== Grid tiles for farming ======
  const tiles = [];
  const tileSize = 1.4;
  const grid = 5; // 5x5 in the center
  const tileGeo = new THREE.BoxGeometry(tileSize, 0.15, tileSize);
  const tileMatEmpty = new THREE.MeshStandardMaterial({ color:0x203048, roughness:0.9, metalness:0.05 });
  const tileMatGrowing = new THREE.MeshStandardMaterial({ color:0x2e4b6d, roughness:0.75, metalness:0.1, emissive:0x0a2238, emissiveIntensity:0.2 });
  const tileMatMature = new THREE.MeshStandardMaterial({ color:0x3b7bb0, roughness:0.65, metalness:0.2, emissive:0x2aa9ff, emissiveIntensity:0.35 });

  for (let x = -Math.floor(grid/2); x <= Math.floor(grid/2); x++) {
    for (let z = -Math.floor(grid/2); z <= Math.floor(grid/2); z++) {
      const t = new THREE.Mesh(tileGeo, tileMatEmpty.clone());
      t.position.set(x* (tileSize+0.2), 0.08, z*(tileSize+0.2));
      t.castShadow = false; t.receiveShadow = true;
      island.add(t);
      tiles.push({
        mesh:t, state:'empty', timer:0, growTime:12, crystal:null
      });
    }
  }

  // ====== Player ======
  const playerGeo = new THREE.SphereGeometry(0.5, 32, 32);
  const playerMat = new THREE.MeshStandardMaterial({
    color:0x9bd8ff, roughness:0.2, metalness:0.6, emissive:0x86bfff, emissiveIntensity:0.2
  });
  const player = new THREE.Mesh(playerGeo, playerMat);
  player.castShadow = true;
  player.position.set(0, 0.6, 4);
  island.add(player);

  // Simple eyes (quad) for a cute look
  const eyeGeo = new THREE.PlaneGeometry(0.12, 0.12);
  const eyeMat = new THREE.MeshBasicMaterial({ color:0x0a0c12, side:THREE.DoubleSide });
  const eyeL = new THREE.Mesh(eyeGeo, eyeMat), eyeR = new THREE.Mesh(eyeGeo, eyeMat);
  eyeL.position.set(-0.18, 0.05, 0.48); eyeR.position.set(0.18, 0.05, 0.48);
  player.add(eyeL); player.add(eyeR);

  // ====== Enemies (slimes) ======
  const enemies = [];
  const enemyGeo = new THREE.SphereGeometry(0.45, 24, 24);
  const enemyMat = new THREE.MeshStandardMaterial({ color:0xf472b6, roughness:0.35, metalness:0.3, emissive:0xff7acb, emissiveIntensity:0.25 });

  function spawnEnemy() {
    const angle = Math.random()*Math.PI*2;
    const r = 6.8;
    const e = new THREE.Mesh(enemyGeo, enemyMat.clone());
    e.castShadow = true;
    e.position.set(Math.cos(angle)*r, 0.5, Math.sin(angle)*r);
    e.userData = { speed: 1.2 + Math.random()*0.6, alive:true };
    island.add(e);
    enemies.push(e);
  }

  // ====== Crystals ======
  function mkCrystal(size=0.2, color=0x67e8f9) {
    const g = new THREE.OctahedronGeometry(size, 0);
    const m = new THREE.MeshStandardMaterial({ color, roughness:0.2, metalness:0.8, emissive:color, emissiveIntensity:0.4 });
    const c = new THREE.Mesh(g, m);
    c.castShadow = true;
    return c;
  }

  // ====== Game State ======
  const state = {
    coins: Number(localStorage.getItem('cf3d_coins') || 0),
    hearts: 3,
    dashCD: 0,
    dashing: false,
    dashTime: 0,
    invuln: 0,
    waveTimer: 4,
    running: false
  };

  // HUD init
  const coinsEl = document.getElementById('coins');
  const heartsEl = document.getElementById('hearts');
  const tipEl = document.getElementById('tip');
  function updateHUD() {
    coinsEl.textContent = state.coins|0;
    heartsEl.innerHTML = '';
    for (let i=0;i<state.hearts;i++) {
      const h = document.createElement('div'); h.className='heart'; heartsEl.appendChild(h);
    }
  }
  updateHUD();

  // ====== Controls: virtual joystick + dash ======
  const stickArea = document.getElementById('stickArea');
  const stick = document.getElementById('stick');
  const btnDash = document.getElementById('btnDash');

  let joy = { active:false, dx:0, dy:0, base:{x:0,y:0} };
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

  function stickToWorld(dx, dy) {
    // dx,dy in [-1..1], map to XZ plane (island space)
    return { x: dx, z: -dy };
  }

  function onStickStart(e){
    joy.active = true;
    const t = e.touches ? e.touches[0] : e;
    const r = stickArea.getBoundingClientRect();
    joy.base.x = t.clientX; joy.base.y = t.clientY;
    moveStick(t.clientX, t.clientY, r);
  }
  function onStickMove(e){
    if(!joy.active) return;
    const t = e.touches ? e.touches[0] : e;
    const r = stickArea.getBoundingClientRect();
    moveStick(t.clientX, t.clientY, r);
  }
  function onStickEnd(){ joy.active=false; joy.dx=0; joy.dy=0; stick.style.left='50%'; stick.style.top='50%'; }

  function moveStick(cx, cy, r){
    const dx = clamp((cx - (joy.base.x))/60, -1, 1);
    const dy = clamp((cy - (joy.base.y))/60, -1, 1);
    joy.dx = dx; joy.dy = dy;
    const sx = clamp((cx - r.left) - r.width/2, -40, 40);
    const sy = clamp((cy - r.top) - r.height/2, -40, 40);
    stick.style.left = `calc(50% + ${sx}px)`;
    stick.style.top  = `calc(50% + ${sy}px)`;
  }

  stickArea.addEventListener('pointerdown', onStickStart, {passive:false});
  stickArea.addEventListener('pointermove', onStickMove, {passive:false});
  window.addEventListener('pointerup', onStickEnd, {passive:true});
  stickArea.addEventListener('touchstart', e=>e.preventDefault(), {passive:false});
  stickArea.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});

  btnDash.addEventListener('click', doDash, {passive:true});

  // ====== Raycaster for tile taps ======
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function onTap(e){
    // Ignore taps on UI areas (dash button / joystick)
    const path = e.composedPath ? e.composedPath() : [];
    if (path.includes(btnDash) || path.includes(stickArea)) return;

    const rect = renderer.domElement.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    mouse.x = ((cx - rect.left)/rect.width ) * 2 - 1;
    mouse.y = -((cy - rect.top )/rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(tiles.map(t=>t.mesh), false);
    if (intersects.length) {
      const m = intersects[0].object;
      const tile = tiles.find(t=>t.mesh===m);
      if (!tile) return;
      if (tile.state==='empty' && state.coins>=50) {
        state.coins -= 50; tile.state='growing'; tile.timer=0;
        m.material = tileMatGrowing;
        // add tiny starter crystal for feedback
        if (!tile.crystal) {
          tile.crystal = mkCrystal(0.01, 0x2aa9ff);
          tile.crystal.position.copy(m.position).add(new THREE.Vector3(0,0.2,0));
          island.add(tile.crystal);
        }
        showTip('Zasiano! Poczekaj a≈º dojrzeje‚Ä¶');
        updateHUD();
      } else if (tile.state==='mature') {
        // harvest
        const gain = 120;
        state.coins += gain;
        tile.state='empty'; tile.timer=0;
        m.material = tileMatEmpty;
        if (tile.crystal) { island.remove(tile.crystal); tile.crystal.geometry.dispose(); tile.crystal.material.dispose(); tile.crystal=null; }
        burst(m.position.x, 0.4, m.position.z, 10, 0x67e8f9);
        showTip(`Zebrano +${gain} üíé`);
        updateHUD();
      } else {
        showTip('Brak monet (50) lub jeszcze ro≈õnie‚Ä¶');
      }
      localStorage.setItem('cf3d_coins', String(state.coins|0));
    }
  }

  renderer.domElement.addEventListener('click', onTap, {passive:true});
  renderer.domElement.addEventListener('touchend', onTap, {passive:true});

  // ====== Particles ======
  const particles = [];
  const pGeo = new THREE.PlaneGeometry(0.06,0.06);
  const pMat = new THREE.MeshBasicMaterial({ color:0x9bd8ff, transparent:true, opacity:1, side:THREE.DoubleSide });

  function burst(x,y,z,count,color){
    for(let i=0;i<count;i++){
      const m = new THREE.Mesh(pGeo, pMat.clone());
      m.material.color = new THREE.Color(color);
      m.position.set(x,y,z);
      m.rotation.y = Math.random()*Math.PI;
      m.userData = {
        vx:(Math.random()-0.5)*2.2, vy:Math.random()*2.3, vz:(Math.random()-0.5)*2.2,
        life:0.7, t:0
      };
      scene.add(m); particles.push(m);
    }
  }

  // ====== Dash / Attack ======
  function doDash(){
    if (state.dashCD>0 || state.dashing===true || !state.running) return;
    state.dashing = true;
    state.dashTime = 0.28;
    state.dashCD = 1.1;
    burst(player.position.x, 0.5, player.position.z, 12, 0xa78bfa);
  }

  // ====== Camera follow ======
  const camTarget = new THREE.Vector3();
  function updateCamera(dt){
    // follow behind player
    const desired = new THREE.Vector3(player.position.x, 3.5, player.position.z + 6);
    camera.position.lerp(desired, 1 - Math.pow(0.001, dt*60));
    camTarget.set(player.position.x, player.position.y+0.6, player.position.z);
    camera.lookAt(camTarget);
  }

  // ====== Tip (toast) ======
  const tip = document.getElementById('tip');
  let tipTimer = 0;
  function showTip(msg){
    tip.textContent = msg;
    tip.classList.add('show');
    tipTimer = 1.5;
  }

  // ====== Game loop ======
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    if (state.running) {
      // Movement
      const move = stickToWorld(joy.dx, joy.dy);
      const speed = state.dashing ? 10 : 3.2;
      player.position.x += move.x * speed * dt;
      player.position.z += move.z * speed * dt;

      // clamp to island disc
      const r = Math.sqrt(player.position.x**2 + player.position.z**2);
      if (r > 7.0) {
        const k = 7.0 / r;
        player.position.x *= k; player.position.z *= k;
      }

      // player tilt a bit
      player.rotation.z = -move.x * 0.15;
      player.rotation.x = move.z * 0.1;

      // Grow tiles
      for (const t of tiles) {
        if (t.state==='growing') {
          t.timer += dt;
          const k = Math.min(1, t.timer / t.growTime);
          // material emissive pulse
          t.mesh.material.emissiveIntensity = 0.2 + 0.25*Math.sin(k*Math.PI*4)*Math.exp(-k*1.2);
          // crystal growth
          if (t.crystal) {
            const s = 0.01 + k*0.35;
            t.crystal.scale.setScalar(THREE.MathUtils.lerp(t.crystal.scale.x||0.01, s, 0.2));
            t.crystal.position.y = 0.2 + k*0.5;
          }
          if (t.timer >= t.growTime) {
            t.state='mature';
            t.mesh.material = tileMatMature;
            if (t.crystal) { t.crystal.material.emissiveIntensity = 0.6; }
            burst(t.mesh.position.x, 0.5, t.mesh.position.z, 6, 0x2aa9ff);
          }
        }
      }

      // Enemies AI
      state.waveTimer -= dt;
      if (state.waveTimer <= 0) {
        spawnEnemy();
        if (Math.random() < 0.6) spawnEnemy();
        state.waveTimer = 3.5 + Math.random()*2;
      }
      for (let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        if (!e.userData.alive) continue;
        const v = new THREE.Vector3().subVectors(player.position, e.position);
        v.y = 0; const len = v.length() || 0.001; v.normalize();
        e.position.addScaledVector(v, e.userData.speed * dt);
        e.rotation.y += dt*2;

        // collide with player
        const dist = e.position.distanceTo(player.position);
        if (dist < 0.8) {
          if (state.dashing) {
            // kill enemy
            e.userData.alive = false;
            burst(e.position.x, 0.5, e.position.z, 10, 0xf472b6);
            island.remove(e); e.geometry.dispose(); e.material.dispose();
            enemies.splice(i,1);
            state.coins += 20; updateHUD();
            localStorage.setItem('cf3d_coins', String(state.coins|0));
          } else if (state.invuln<=0) {
            state.hearts--; state.invuln = 1.2;
            updateHUD();
            if (state.hearts<=0) {
              endGame();
              return;
            }
          }
        }
      }

      // Dash timers
      if (state.dashing) {
        state.dashTime -= dt;
        if (state.dashTime <= 0) state.dashing = false;
      }
      if (state.dashCD>0) state.dashCD -= dt;
      if (state.invuln>0) state.invuln -= dt;

      // Particles
      for (let i=particles.length-1;i>=0;i--){
        const p = particles[i], u = p.userData;
        u.t += dt; p.position.x += u.vx*dt; p.position.y += u.vy*dt; p.position.z += u.vz*dt;
        u.vy -= 3.5*dt;
        p.material.opacity = Math.max(0, 1 - u.t/u.life);
        if (u.t >= u.life) { scene.remove(p); p.geometry.dispose(); p.material.dispose(); particles.splice(i,1); }
      }

      // Camera follow
      updateCamera(dt);
    }

    // Tip
    if (tipTimer>0){ tipTimer -= dt; if (tipTimer<=0) tip.classList.remove('show'); }

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ====== Start / Game Over / Add to Home ======
  const startOv = document.getElementById('startOv');
  const gameOver = document.getElementById('gameOver');
  const playBtn = document.getElementById('playBtn');
  const againBtn = document.getElementById('againBtn');
  const finalScore = document.getElementById('finalScore');
  const addBtn = document.getElementById('addBtn');

  let deferredPrompt = null;
  window.addEventListener('beforeinstallprompt', (e)=>{ e.preventDefault(); deferredPrompt = e; });
  addBtn.addEventListener('click', async ()=>{
    if (deferredPrompt){ deferredPrompt.prompt(); await deferredPrompt.userChoice; deferredPrompt=null; }
    else alert('Na iPhonie: Udostƒôpnij ‚Üí Dodaj do ekranu poczƒÖtkowego');
  });

  function begin(){
    state.running = true;
    state.hearts = 3;
    updateHUD();
    showTip('Dotknij p≈Çytki, aby zasadziƒá / zebraƒá');
    startOv.classList.add('hidden');
    gameOver.classList.add('hidden');
  }
  function endGame(){
    state.running = false;
    finalScore.textContent = state.coins|0;
    gameOver.classList.remove('hidden');
  }

  playBtn.addEventListener('click', begin, {passive:true});
  againBtn.addEventListener('click', begin, {passive:true});

  // ====== Resize ======
  function onResize(){
    const w = window.innerWidth, h = window.innerHeight;
    renderer.setSize(w,h);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize, {passive:true});

})();
</script>
</body>
</html>
